#include "BaseKnotSequence.h"
#include <vector>
#include <cmath>
#include <Utils.h>
#include <iostream>

using namespace std;

typedef std::vector<double> doubles;
typedef std::vector<Point> Points;

BaseKnotSequence::BaseKnotSequence()
:BaseKnotSequence(0, 0.0, 1.0)
{
}

BaseKnotSequence::BaseKnotSequence(int  numParams, double start, double end)
{
    this->numParams = numParams;
    this->start = start;
    this->end = end;
}

BaseFixedKnotSequence::BaseFixedKnotSequence(double start, double end)
:BaseKnotSequence(0, start, end)
{
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

UniformKS::UniformKS(double start, double end)
:BaseKnotSequence(1, start, end)
{
}

doubles UniformKS::getSequence(doubles params)
{
    return Utils::linspace(this->start, this->end, (int)params[0]);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

UniformFixedKS::UniformFixedKS(double start, double end, int steps)
:BaseFixedKnotSequence(start, end)
,UniformKS(start, end)
{
    this->steps = steps;
}

doubles UniformFixedKS::getSequence()
{
    doubles params = {(double)this->steps};
    return UniformKS::getSequence(params);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

ValueFixedKS::ValueFixedKS(double value)
:BaseFixedKnotSequence(value, value)
{
}

doubles ValueFixedKS::getSequence()
{
    doubles d = {this->getStart()};
    return d;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

MultiplicityFixedValueKS::MultiplicityFixedValueKS(double value, int multiplicity)
:UniformFixedKS(value, value, multiplicity)
{
}

doubles MultiplicityFixedValueKS::getSequence()
{
    return UniformFixedKS::getSequence();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

MultiplicityValueKS::MultiplicityValueKS(double value)
:UniformKS(value, value)
{
}

doubles MultiplicityValueKS::getSequence(doubles params)
{
    return UniformKS::getSequence(params);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

BeginKS::BeginKS(int bspline_n)
:MultiplicityFixedValueKS(0, bspline_n + 1)
{
}

doubles BeginKS::getSequence()
{
    return MultiplicityFixedValueKS::getSequence();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

EndKS::EndKS(int bspline_n)
:MultiplicityFixedValueKS(1, bspline_n + 1)
{
}

doubles EndKS::getSequence()
{
    return MultiplicityFixedValueKS::getSequence();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

RationalKS::RationalKS(double start, double end, int numpoints)
:BaseKnotSequence(1, start, end)
{
    this->numpoints = numpoints;
}

doubles RationalKS::getSequence(doubles params)
{
    // return contains both start and end points, so numpoints+1 items
    double q = params[0];
    // a*(1 + 1/q + 1/q^2+...) = end - start = b
    double b = this->end - this->start;
    double a = b / this->numpoints;
    if (q != 1.0)
        a = b / (1.0 - pow( 1.0 / q, this->numpoints)) * (1.0 - 1.0 / q);

    doubles uarray(this->numpoints + 1);

    // add one more index which is the start point
    uarray[0] = this->start;
    for (int i = 1; i < this->numpoints + 1; i++)
    {
        uarray[i] = uarray[i - 1] + a / pow(q, i - 1);
    }
    //uarray.insert(uarray.begin(), this->start);
    return uarray;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

RationalFixedKS::RationalFixedKS(double start, double end, int numpoints, double q)
:BaseFixedKnotSequence(start, end)
,RationalKS(start, end, numpoints)
{
    this->q = q;
}

doubles RationalFixedKS::getSequence()
{
    doubles params = {(double)this->q};
    return RationalKS::getSequence(params);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


BiRationalKS::BiRationalKS(double start, double end, int numpoints)
:RationalKS(start, end, numpoints)
{
    this->numParams = 3; // override value of rationalKS
    this->numpoints = numpoints;
}

doubles BiRationalKS::getSequence(doubles params)
{
    double q1 = params[0];
    double q2 = params[1];
    double center = params[2];
    // backup start and end values
    double bkp_start = this->BaseKnotSequence::getStart();
    double bkp_end = this->getEnd();

    // call rational getsequence for the left range:
    this->start = bkp_start;
    this->end = center;
    doubles uarray_left = RationalKS::getSequence({q1});

    // call rational getsequence for the right range:
    this->start = center;
    this->end = bkp_end;
    doubles uarray_right = RationalKS::getSequence({q2});
    uarray_left.pop_back(); // the center element is inserted 2 times so we remove one occurrence

    //restore start and end values
    this->start = bkp_start;
    this->end = bkp_end;

    // concatenate left and right
    doubles uarray(uarray_left);
    uarray.insert(uarray.end(), uarray_right.begin(), uarray_right.end());
    return uarray;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

BiRationalFixedKS::BiRationalFixedKS(double start, double end, int numpoints, double q1, double q2, double center)
:BaseFixedKnotSequence(start, end)
,BiRationalKS(start, end, numpoints)
{
    this->q1 = q1;
    this->q2 = q2;
    this->center = center;
}

doubles BiRationalFixedKS::getSequence()
{
    doubles params = {this->q1, this->q2, this->center};
    return BiRationalKS::getSequence(params);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
